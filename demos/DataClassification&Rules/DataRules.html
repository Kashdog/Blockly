<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Blockly Demo: Toolbox</title>
    <script src="../../blockly_compressed.js"></script>
    <script src="../../blocks_compressed.js"></script>
    <script src="../../datarulegeneration_compressed.js"></script>
    <script src="./datarules.js"></script>
    <script src="../../msg/js/en.js"></script>
    <style>
        body {
            background-color: #fff;
            font-family: sans-serif;
        }
        
        h1 {
            font-weight: normal;
            font-size: 140%;
        }
    </style>
</head>

<body>
    <div id="blocklyDiv" style="height: 600px; width: 1400px;"></div>
    <xml id="toolbox" style="display: none">
        <category name="General Functions"></category>
        <category name="Date/Time Functions"></category>
        <category name="Math Functions"></category>
        <category name="String Functions"></category>
        <category name="Tests"></category>
        <category name="Operations">
            <block id="addition" type="addition"></block>
            <block id="subtraction" type="subtraction"></block>
            <block id="multiplication" type="multiplication"></block>
            <block id="division" type="division"></block>
            <block id="power" type="power"></block>
            <block id="modulo" type="modulo"></block>
        </category>
        <category name="Variables and Literals">
            <block id="variable" type="variable"></block>
            <block id="numericliteral" type="numericliteral"></block>
            <block id="stringliteral" type="stringliteral"></block>
        </category>
        <category name="Boolean">
            <block id="ifthen" type="ifthen"></block>
            <block id="ifthenelse" type="ifthenelse"></block>
            <block id="and" type="and"></block>
            <block id="or" type="or"></block>
            <block id="not" type="not"></block>
        </category>
    </xml>
    <script>
        var workspace = Blockly.inject('blocklyDiv', {
            media: '../../media/'
            , toolbox: document.getElementById('toolbox')
        });

        var xml = Blockly.Xml.textToDom('<xml xmlns="http://www.w3.org/1999/xhtml"><variables></variables></xml>');
        Blockly.Xml.domToWorkspace(xml, workspace);

        function myUpdateFunction(event) {
            var code = Blockly.DataRule.workspaceToCode(workspace);
            /*if (code.substring(code.length - 2, code.length - 1) == ";"){
                code = code.substring(0, code.length - 2);
            }*/
            document.getElementById("generatedCode").innerHTML = "Generated Code: " + code;

        }
        workspace.addChangeListener(myUpdateFunction);

        function showCode() {
            // Generate JavaScript code and display it.
            Blockly.DataRule.INFINITE_LOOP_TRAP = null;
            var code = Blockly.DataRule.workspaceToCode(workspace);
            alert(code);
        }

        function downloadXML() {
            var xml = Blockly.Xml.workspaceToDom(workspace);
            var xml_text = Blockly.Xml.domToText(xml);
            alert(xml_text);
            var dl = document.createElement('a');
            dl.setAttribute('href', 'data:text/csv;charset=utf-8,' + encodeURIComponent(xml_text));
            dl.setAttribute('download', 'DataClassificationBlocks.txt');
            dl.click();
        }
    </script>
    <button onClick="showCode()">Generate Rule</button>
    <button onClick="downloadXML()">Export the Blocks</button>
    <input type="file" id="fileinput" />
    <script type="text/javascript">
        function readSingleFile(evt) {
            //Retrieve the first (and only!) File from the FileList object
            var f = evt.target.files[0];
            if (f) {
                var r = new FileReader();
                r.onload = function (e) {
                    var contents = e.target.result;
                    alert(contents);
                    var xml = Blockly.Xml.textToDom(contents);
                    Blockly.Xml.domToWorkspace(xml, workspace);
                }
                r.readAsText(f);
            } else {
                alert("Failed to load file");
            }
        }
        document.getElementById('fileinput').addEventListener('change', readSingleFile, false);
    </script> Load Palette
    <input type="file" id="loadpalette" />
    <script type="text/javascript">
        function readSingleFile(evt) {
            //Retrieve the first (and only!) File from the FileList object
            var f = evt.target.files[0];
            if (f) {
                var r = new FileReader();
                r.onload = function (e) {
                    var contents = e.target.result;
                    if (window.DOMParser) {
                        parser = new DOMParser();
                        xmlDoc = parser.parseFromString(contents, "text/xml");
                    } else // Internet Explorer
                    {
                        xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
                        xmlDoc.async = false;
                        xmlDoc.loadXML(contents);
                    }
                    var x = xmlDoc.getElementsByTagName('DataRuleFunction'); // get all the data rule functions tags
                    var general_functions, datetime_functions, math_functions, string_functions, datarule_tests;

                    /*
                      Gather all the category tags for blocks for the functions
                    */
                    for (var j = 0; j < document.getElementsByTagName('category').length; j++) {
                        if (document.getElementsByTagName('category')[j].getAttribute("name") == "General Functions") {
                            general_functions = document.getElementsByTagName('category')[j];
                        }
                        if (document.getElementsByTagName('category')[j].getAttribute("name") == "Date/Time Functions") {
                            datetime_functions = document.getElementsByTagName('category')[j];
                        }
                        if (document.getElementsByTagName('category')[j].getAttribute("name") == "Math Functions") {
                            math_functions = document.getElementsByTagName('category')[j];
                        }
                        if (document.getElementsByTagName('category')[j].getAttribute("name") == "String Functions") {
                            string_functions = document.getElementsByTagName('category')[j];
                        }
                    }
                    /*
                 
                    Create Blocks by parsing the tags
                    */
                    [].forEach.call(x, function (arrayElement) {
                        var function_name = arrayElement.getAttribute('name');
                        var display_name = arrayElement.getAttribute('displayName');
                        var returnType = arrayElement.getAttribute('returnType');
                        if (returnType == "any") {
                            returnType = null;
                        }
                        var description = arrayElement.getElementsByTagName("description")[0].innerHTML;
                        var param_displayNames = [];
                        var param_returnTypes = [];
                        for (var paramCounter = 0; paramCounter < arrayElement.getElementsByTagName("Parameter").length; paramCounter++) {
                            param_displayNames.push(arrayElement.getElementsByTagName("Parameter")[paramCounter].getAttribute('displayName'));
                            if (arrayElement.getElementsByTagName("Parameter")[paramCounter].getAttribute('type') == "any") {
                                param_returnTypes.push(null);
                            } else{
                                param_returnTypes.push(arrayElement.getElementsByTagName("Parameter")[paramCounter].getAttribute('type'));
                            }
                            /*
                            var inputName = "input" + paramCounter;
                            this.appendValueInput(inputName)
                                    .setCheck(param_returnTypes[paramCounter])
                                    .appendField(param_displayNames[paramCounter]);
                            */
                        }
                        var setChecks;
                        var blocks = document.createElement('block'); // create a block tag
                        blocks.id = function_name; // give the block id to be the function name
                        blocks.setAttribute("type", function_name); // set the type attribute of the tag
                        //childNodes[0].nodeValue// Append the block tag into the xml toolbox categories
                        if (arrayElement.getAttribute('categoryID') == 'general') {
                            general_functions.appendChild(blocks);
                        } else if (arrayElement.getAttribute('categoryID') == 'date/time') {
                            datetime_functions.appendChild(blocks);
                        } else if (arrayElement.getAttribute('categoryID') == 'math') {
                            math_functions.appendChild(blocks);
                        } else if (arrayElement.getAttribute('categoryID') == 'string') {
                            string_functions.appendChild(blocks);
                        }
                        /*
                            Block Definition using function_name variable
                        */
                        Blockly.Blocks[function_name] = {
                            init: function () {
                                this.appendDummyInput()
                                    .appendField(function_name);
                                this.appendValueInput("input")
                                    .setCheck(param_returnTypes[0])
                                    .appendField("(");
                                this.appendDummyInput()
                                    .appendField(")");
                                this.setInputsInline(true);
                                this.setOutput(true, returnType);
                                this.setColour(218);
                                this.setTooltip("");
                                this.setHelpUrl("");
                            }
                        };

                        /*
                            Block Generation using function_name variable
                        */
                        Blockly.DataRule[function_name] = function (block) {
                            var value_input = Blockly.DataRule.valueToCode(block, 'input', Blockly.DataRule.ORDER_ATOMIC);
                            var code = function_name + '(' + value_input + ')';
                            return [code, Blockly.DataRule.ORDER_ATOMIC];
                        };
                    });
                    x = xmlDoc.getElementsByTagName('DataRuleTest');
                    for (var k = 0; k < document.getElementsByTagName('category').length; k++) {
                        if (document.getElementsByTagName('category')[k].getAttribute("name") == "Tests") {
                            datarule_tests = document.getElementsByTagName('category')[k];
                        }
                    }
                    var test_names = '';
                    [].forEach.call(x, function (arrayElement) {
                        var function_name = arrayElement.getAttribute('name');
                        var display_name = arrayElement.getAttribute('displayName');
                        var description = arrayElement.getElementsByTagName("description")[0].innerHTML;
                        var test_operand_type1 = arrayElement.getElementsByTagName("TestOperand")[0].getAttribute('type');
                        var test_operand_type2 = arrayElement.getElementsByTagName("TestOperand")[1].getAttribute('type');
                        if (test_operand_type1 == "any") {
                            test_operand_type1 = null;
                        }
                        if (test_operand_type2 == "any") {
                            test_operand_type2 = null;
                        }
                        if (arrayElement.getElementsByTagName("TestOperand")[1].getElementsByTagName("TestOperandConstraint").length > 0 && arrayElement.getElementsByTagName("TestOperand")[1].getElementsByTagName("TestOperandConstraint")[0].getAttribute("type") == "mustBeEmpty") {
                            Blockly.Blocks[function_name] = {
                                init: function () {
                                    this.appendValueInput("Operand1").setCheck(test_operand_type1);
                                    this.appendDummyInput().appendField(function_name);
                                    this.setInputsInline(true);
                                    this.setOutput(true, "Boolean");
                                    this.setColour(186);
                                    this.setTooltip("");
                                    this.setHelpUrl("");
                                }
                            };
                            Blockly.DataRule[function_name] = function (block) {
                                var value_name1 = Blockly.DataRule.valueToCode(block, 'Operand1', Blockly.DataRule.ORDER_ATOMIC);
                                var code = value_name1 + ' ' + function_name + ' ';
                                return [code, Blockly.DataRule.ORDER_ATOMIC];
                            };
                        } else {
                            Blockly.Blocks[function_name] = {
                                init: function () {
                                    this.appendValueInput("Operand1").setCheck(test_operand_type1);
                                    this.appendValueInput("Operand2").setCheck(test_operand_type2).appendField(function_name);
                                    this.setInputsInline(true);
                                    this.setOutput(true, "Boolean");
                                    this.setColour(186);
                                    this.setTooltip("");
                                    this.setHelpUrl("");
                                }
                            };
                            Blockly.DataRule[function_name] = function (block) {
                                var value_name1 = Blockly.DataRule.valueToCode(block, 'Operand1', Blockly.DataRule.ORDER_ATOMIC);
                                var value_name2 = Blockly.DataRule.valueToCode(block, 'Operand2', Blockly.DataRule.ORDER_ATOMIC);
                                var code = value_name1 + ' ' + function_name + ' ' + value_name2;
                                return [code, Blockly.DataRule.ORDER_ATOMIC];
                            };
                        }
                        var blocks = document.createElement('block');
                        blocks.id = function_name;
                        blocks.setAttribute("type", function_name);
                        datarule_tests.appendChild(blocks);
                    });
                    workspace.updateToolbox(document.getElementById('toolbox'));
                }
                r.readAsText(f);
            } else {
                alert("Failed to load file");
            }
        }
        document.getElementById('loadpalette').addEventListener('change', readSingleFile, false);
    </script>
    <br>
    <br>
    <div id="generatedCode">Generated Code: </div>
</body>

</html>